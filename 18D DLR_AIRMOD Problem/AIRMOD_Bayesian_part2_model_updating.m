load('metamodel_light','Xnn_no_data');

[~,hostname]=system('hostname'); hostname(end)=[]; % Identify name of the computer
directory = 'workfolder';                          % Identify directory

%% What time and date is it?
datetimenow = datestr(clock);

%% Load the experimental data (as a column vector):
load('SMUdata.mat');      
D = dataCloud{1,1};

% Remove failed experiments (all NaN on a line)
idxNaN = all(isnan(D),2);
D(idxNaN,:) = [];
Nexpsamples = size(D,1);

% Keep only selected modes 
selected_modes = [1:8,10:12,14,19,20];
D = D(:,selected_modes);

%% Defining the prior PDF, p(theta):
Xrvset = Xnn_no_data(1).Xinput.Xrvset.(Xnn_no_data(1).Xinput.CnamesRandomVariableSet{1});

% The variance is to be inferred from the data:
fixed_variance = false;

if ~fixed_variance
    std_lb = 1e-4; 
    std_ub = 10*sqrt(nanvar(D.^2))./nanmean(D.^2);
    std_ub([11,13]) = 10*std_ub([11,13]);
    
    p_theta    = @(x) prod([Xrvset.evalpdf('Mxsamples',x(:,1:Xrvset.Nrv)),...
                            unifpdf(x(:,Xrvset.Nrv+(1:length(selected_modes))),std_lb, std_ub)], 2); 

    p_thetarnd = @(N) [get(Xrvset.sample('Nsamples', N),'MsamplesPhysicalSpace'),...
                   unifrnd(std_lb, repmat(std_ub, N, 1))];
else
    p_theta = @(x)Xrvset.evalpdf('Mxsamples',x);
    p_thetarnd = @(N) get(Xrvset.sample('Nsamples', N),'MsamplesPhysicalSpace');
end

%% The loglikelihood of D given theta:
log_p_D_theta = @(theta) Airmod_log_p_D_theta(D, theta, Xnn_no_data, selected_modes);

%% The Posterior Distribution function:
target_PDF = @(x) log(p_theta(x)) + log_p_D_theta(x);

%% Bayesian estimation of theta: Bayesian model updating using MH sampling
% Details to the MH algorithm in sampling from a 18-dimensional posterior
% can be found in Algorithm 3 of the Tutorial paper.

% Define the array of variance which is adopted from the results of the
% sensitivity model updating:
var = [1.08E+02, 2.40E+02, 1.09E+02, 2.03, 2.24, 3.50E+05, 2.56E+08,...
    7.60E-03, 4.65E-03, 4.28E-03, 1.26E-03, 1.22E-03, 1.65E-04, 1.32E+06,...
    1.06E+06, 1.89E+05, 2.80E+06, 6.90E+05, 6.00E-04, 1.90E-03, 1.70E-03,...
    2.40E-03, 4.00E-04, 1.70E-03, 2.00E-03, 1.70E-03, 1.50E-03, 1.49E-02,...
    1.20E-03, 2.74E-02, 1.023E-01, 1.663E-01].^2;

% Define the Tuning parameter for the MH sampler:
Tuning_mcmc = (10^-1).*var.*eye(32);

% Define the Proposal distribution for the MH sampler:
proppdf = @(x,y) mvnpdf(x,y,Tuning_mcmc);
proprnd = @(x) mvnrnd(x, Tuning_mcmc);

% Defining the variables:
Nsamples_mcmc = 1000;
NumberOfChain = 1;
Start = p_thetarnd(NumberOfChain);
BurnIn = 500;

% Run the MH sampler:
tic;
[samples_mcmc,accept] = mhsample(Start,Nsamples_mcmc,'logpdf',target_PDF,'proppdf',proppdf,...
'proprnd',proprnd,'symmetric',1, 'burnin', BurnIn, 'nchain', NumberOfChain);
timeMCMC = toc;

fprintf('Accept Level = %d\n', accept);
fprintf('Time elapsed is for the MCMC sampler: %f \n',timeMCMC);

%% Determine Coefficient of Variation of estimate:

mcmc_mean = mean(samples_mcmc); % To calcuate the sample mean
mcmc_std = std(samples_mcmc);   % To calculate the sample standard deviation
COV_mcmc = (mcmc_std./mcmc_mean)*100; % To calculate the percentage error of the estimation

%% Plot the scatterplot matrix of samples generated by the MH sampler:

% To normalise the samples obtained via MH sampling such that they now take
% values between 0 and 1:
theta_mcmc = normalize(samples_mcmc(:,1:18),'range',[0,1]);

% Plotting the scatterplot matrix:
figure();
[~,ax1] = plotmatrix(theta_mcmc);
title('MCMC Scatterplot Matrix', 'Fontsize', 22);
for i=1:18
    t = 13;
    xlabel(ax1(18,i),sprintf('\\theta_{%d}', i), 'Fontsize', t);
    ylabel(ax1(i,1), sprintf('\\theta_{%d}', i), 'Fontsize', t);
    set(ax1(18,i),'XTickLabel',[])
    set(ax1(i,1),'YTickLabel',[])
end

%% Run the model with the posterior distributions of the inputs:
% (MCMC Model updating results) 

% To generate frequency output samples from the updated model:
Xinput_post_mcmc = Xnn_no_data(1).Xinput.sample('Nsamples',1);
Xinput_post_mcmc.Xsamples.MsamplesPhysicalSpace = samples_mcmc(:,1:18);
output_mcmc = zeros(Xinput_post_mcmc.Nsamples,length(selected_modes));
for imode = 1:length(selected_modes)
    Xout_mcmc = Xnn_no_data(selected_modes(imode)).apply(Xinput_post_mcmc);
    output_mcmc(:,imode)  = Xout_mcmc.getValues('CSnames',Xnn_no_data(selected_modes(imode)).Coutputnames(1));
end

% To generate scatterplot matrix of the frequency output samples from the
% updated model and that obtained from experiment:
figure();
plotEigenvaluesScatter(output_mcmc,D);

%% Bayesian estimation of theta: Bayesian model updating using TMCMC
% Details to the TMCMC algorithm in sampling from a 18-dimensional posterior
% can be found in Algorithm 6 of the Tutorial paper.

% Defining the variables:
Nsamples_tmcmc = 1000;

% Run the TMCMC sampler:
tic;
samples_tmcmc = TMCMCsampler('nsamples',Nsamples,'loglikelihood',log_p_D_theta,...
    'priorpdf',p_theta,'priorrnd',p_thetarnd,'burnin',50,'lastburnin',200);
timeTMCMC = toc;

fprintf('Time elapsed is for the TMCMC sampler: %f \n',timeTMCMC);

%% Determine Coefficient of Variation of estimate:

tmcmc_mean = mean(samples_tmcmc); % To calcuate the sample mean
tmcmc_std = std(samples_tmcmc);   % To calculate the sample standard deviation
COV_tmcmc = (tmcmc_std./tmcmc_mean)*100; % To calculate the percentage error of the estimation

%% Plot the scatterplot matrix of samples generated by the TMCMC sampler:

% To normalise the samples obtained via MH sampling such that they now take
% values between 0 and 1:
theta_tmcmc = normalize(samples_tmcmc(:,1:18),'range',[0,1]);

% Plotting the scatterplot matrix:
figure();
[~,ax2] = plotmatrix(theta_tmcmc);
title('TMCMC Scatterplot Matrix', 'Fontsize', 22);
for i=1:18
    t = 13;
    xlabel(ax2(18,i),sprintf('\\theta_{%d}', i), 'Fontsize', t);
    ylabel(ax2(i,1), sprintf('\\theta_{%d}', i), 'Fontsize', t);
    set(ax2(18,i),'XTickLabel',[])
    set(ax2(i,1),'YTickLabel',[])
end

%% Run the model with the posterior distributions of the inputs:
% (TMCMC Model updating results) 

% To generate frequency output samples from the updated model:
Xinput_post_tmcmc = Xnn_no_data(1).Xinput.sample('Nsamples',1);
Xinput_post_tmcmc.Xsamples.MsamplesPhysicalSpace = samples_tmcmc(:,1:18);
output_tmcmc = zeros(Xinput_post_tmcmc.Nsamples,length(selected_modes));
for imode = 1:length(selected_modes)
    Xout_tmcmc = Xnn_no_data(selected_modes(imode)).apply(Xinput_post_tmcmc);
    output_tmcmc(:,imode)  = Xout_tmcmc.getValues('CSnames',Xnn_no_data(selected_modes(imode)).Coutputnames(1));
end

% To generate scatterplot matrix of the frequency output samples from the
% updated model and that obtained from experiment:
figure();
plotEigenvaluesScatter(output_tmcmc,D);

%% Bayesian estimation of theta: bayesian model updating using SMC
% Details to the SMC algorithm in sampling from a 18-dimensional posterior
% can be found in Algorithm 9 of the Tutorial paper.

% Define the Tuning parameter for the SMC sampler:
Tuning_smc = (10^-1).*var.*eye(32);

% Defining the variables:
Nsamples_smc = 1000;
no_iterations = 1;

% Run the SMC sampler:
tic;
smc = SMCsampler('nsamples',Nsamples_smc,...
    'prior_values',p_thetarnd(Nsamples_smc),'prior',p_theta,'loglikelihood',log_p_D_theta,...
    'no_iterations',no_iterations,'prop_covariance',Tuning_smc);
smc = smc.generate_samples();
samples_smc = smc.theta;
timeSMC = toc;

fprintf('Time elapsed is for the SMC sampler: %f \n',timeSMC);

%% Determine Coefficient of Variation of estimate:

smc_mean = mean(samples_smc); % To calcuate the sample mean
smc_std = std(samples_smc);   % To calculate the sample standard deviation
COV_smc = (smc_std./smc_mean)*100; % To calculate the percentage error of the estimation

%% Plot the scatterplot matrix of samples generated by the SMC sampler:

% To normalise the samples obtained via MH sampling such that they now take
% values between 0 and 1:
theta_smc = normalize(samples_smc(:,1:18),'range',[0,1]);

% Plotting the scatterplot matrix:
figure();
[~,ax3] = plotmatrix(theta_smc);
title('SMC Scatterplot Matrix', 'Fontsize', 22);
for i=1:18
    t = 13;
    xlabel(ax3(18,i),sprintf('\\theta_{%d}', i), 'Fontsize', t);
    ylabel(ax3(i,1), sprintf('\\theta_{%d}', i), 'Fontsize', t);
    set(ax3(18,i),'XTickLabel',[])
    set(ax3(i,1),'YTickLabel',[])
end

%% Run the model with the posterior distributions of the inputs:
% (SMC Model updating results) 

% To generate frequency output samples from the updated model:
Xinput_post_smc = Xnn_no_data(1).Xinput.sample('Nsamples',1);
Xinput_post_smc.Xsamples.MsamplesPhysicalSpace = samples_smc(:,1:18);
output_smc = zeros(Xinput_post_smc.Nsamples,length(selected_modes));
for imode = 1:length(selected_modes)
    Xout_smc = Xnn_no_data(selected_modes(imode)).apply(Xinput_post_smc);
    output_smc(:,imode)  = Xout_smc.getValues('CSnames',Xnn_no_data(selected_modes(imode)).Coutputnames(1));
end

% To generate scatterplot matrix of the frequency output samples from the
% updated model and that obtained from experiment:
figure();
plotEigenvaluesScatter(output_smc,D);

%%
diary off;
